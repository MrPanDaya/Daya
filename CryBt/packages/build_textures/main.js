var fs = require('fs');
var path = require('path');
function buildInterlnal (options) {
    Editor.assetdb.queryAssets('db://internal/**/*', '', (err, assetInfos) => {
        var tb = {}
        var count = 0;
        for (var idx in options.bundles) {
            var oneBundle = options.bundles[idx];
            let buildResults = oneBundle.buildResults;
            var isPackedAssets = function(uuid) {
                for (var key in buildResults._packedAssets) {
                    var list = buildResults._packedAssets[key]
                    for (let i = 0; i < list.length; ++i) {
                        if (uuid == list[i]) {
                            return key;
                        }
                    }
                }
            }
            for (let i = 0; i < assetInfos.length; ++i) {
                let info = assetInfos[i];
                if (buildResults.containsAsset(info.uuid)) {
                    let depends = buildResults.getDependencies(info.uuid);
                    var uuid = info.uuid;
                    //Editor.log(depends.length, uuid);
                    let p1 = buildResults.getNativeAssetPath(uuid);
                    if (p1 != '') {
                        var idx = p1.indexOf("res\\");
                        p1 = p1.substr(idx);
                        p1 = p1.replace(/\\/g, "/")
                        tb[p1] = 1;
                        //Editor.log(p1);
                    } else {
                        var packid = isPackedAssets(uuid);
                        var name = uuid;
                        if (packid) {
                            name = packid;
                        }
                        name = 'res/import/'+ name[0] + name[1] + '/' + name + ".json"
                        tb[name] = 1;
                    }
                }
            }
        }

        Editor.log(tb);
        Editor.log(count);
        var mainJsPath = path.join(options.project, '/packConfig/tools/hall/utils/interlnal.json');
        fs.writeFileSync(mainJsPath, JSON.stringify(tb));
    });
}

function onBuildFinish (options, callback) {
    Editor.log("build options: ", options);

    // get path of textures auto generated by auto atlas
    Editor.assetdb.queryAssets('db://assets/**/*', 'sprite-frame', (err, assetInfos) => {
        var tb = {}
        var count = 0;
        for (var idx in options.bundles) {
            var oneBundle = options.bundles[idx];
            let buildResults = oneBundle.buildResults;

            let textures = _getTextureFromSpriteFrames(buildResults, assetInfos);
            for (var key in textures) {
                let p1 = buildResults.getNativeAssetPath(key);
                p1 = p1.replace(/\\/g, "/")
                var idx = p1.indexOf("resources/");
                if (idx >= 0) {
                    p1 = p1.substr(idx);
                }
                tb[p1] = textures[key];
                count++;
            }
        }

        var mainJsPath = path.join(options.dest, 'PngMap.json');
        fs.writeFileSync(mainJsPath, JSON.stringify(tb));
    });

    Editor.assetdb.queryAssets('db://assets/**/*', 'json', (err, assetInfos) => {
        var tb = {}
        var count = 0;
        for (var idx in options.bundles) {
            var oneBundle = options.bundles[idx];
            let buildResults = oneBundle.buildResults;
            for (let i = 0; i < assetInfos.length; ++i) {
                let info = assetInfos[i];
                if (buildResults.containsAsset(info.uuid)) {
                    let hashStr = buildResults._md5Map[info.uuid]
                    let key = info.uuid + "." + hashStr + ".json";
                    tb[key] = info.url;
                    count++;
                }
            }
        }

        var jsonPath = path.join(options.dest, 'ConfigMap.json');
        fs.writeFileSync(jsonPath, JSON.stringify(tb));
    });

    // get all textures in build
    //Editor.log(`All textures in build: ${textures}`);
    // buildInterlnal(options);
    callback();
}

function _getTextureFromSpriteFrames (buildResults, assetInfos) {
    let textures = {};
    for (let i = 0; i < assetInfos.length; ++i) {
        let info = assetInfos[i];
        if (buildResults.containsAsset(info.uuid)) {
            let depends = buildResults.getDependencies(info.uuid);
            if (depends.length > 0) {
                // sprite frame should have only one texture
                textures[depends[0]] = info.url;
            }
        }
    }
    return textures;
}

module.exports = {
    load () {
        Editor.Builder.on('build-finished', onBuildFinish);
    },

    unload () {
        Editor.Builder.removeListener('build-finished', onBuildFinish);
    }
};